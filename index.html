<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Yeye & Yuanyuan | ETERNAL</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Ma+Shan+Zheng&family=Montserrat:wght@200;400&display=swap" rel="stylesheet">
    
    <style>
        /* === 1. 基础环境设置 === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background-color: #050505;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Montserrat', sans-serif;
            perspective: 1000px; /* 3D 透视深度的关键 */
        }

        /* === 2. 画布层 (背景星海) === */
        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }

        /* === 3. UI 悬浮层 (玻璃拟态) === */
        .glass-container {
            position: relative;
            z-index: 10;
            padding: 40px 60px;
            background: rgba(255, 255, 255, 0.03); /* 极淡的背景 */
            backdrop-filter: blur(10px); /* 毛玻璃模糊 */
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            text-align: center;
            transform-style: preserve-3d; /* 保持3D变换 */
            transition: transform 0.1s ease-out; /* 鼠标跟随的平滑过渡 */
            animation: floatUI 6s ease-in-out infinite; /* 自身的呼吸浮动 */
        }

        @keyframes floatUI {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* === 4. 文字排版系统 === */
        
        /* 顶部日期 */
        .since-date {
            font-family: 'Cinzel', serif;
            font-size: 12px;
            letter-spacing: 4px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 30px;
            text-transform: uppercase;
        }

        /* 名字区域 */
        .names-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 40px;
        }

        .name-item {
            position: relative;
        }

        .nickname {
            font-family: 'Ma Shan Zheng', cursive; /* 书法体 */
            font-size: 3rem;
            line-height: 1;
            white-space: nowrap;
        }

        /* 男生名字特效 (青蓝霓虹) */
        .male {
            color: #e0f7fa;
            text-shadow: 0 0 10px rgba(0, 210, 255, 0.7),
                         0 0 20px rgba(0, 210, 255, 0.5),
                         0 0 40px rgba(0, 210, 255, 0.3);
            animation: pulseBlue 3s infinite alternate;
        }

        /* 女生名字特效 (粉紫霓虹) */
        .female {
            color: #fce4ec;
            text-shadow: 0 0 10px rgba(255, 75, 139, 0.7),
                         0 0 20px rgba(255, 75, 139, 0.5),
                         0 0 40px rgba(255, 75, 139, 0.3);
            animation: pulsePink 3s infinite alternate;
        }

        /* 中间的连接符 */
        .divider {
            font-size: 1.5rem;
            opacity: 0.5;
            font-family: 'Cinzel', serif;
        }

        /* 计时器区域 */
        .timer-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            padding-top: 25px;
        }

        .t-box { display: flex; flex-direction: column; align-items: center; }
        
        .t-val {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            font-weight: 700;
            background: -webkit-linear-gradient(#fff, #aaa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .t-label {
            font-size: 0.6rem;
            letter-spacing: 2px;
            opacity: 0.5;
            margin-top: 5px;
            text-transform: uppercase;
        }

        /* 底部情话 */
        .footer-quote {
            margin-top: 30px;
            font-size: 12px;
            opacity: 0.7;
            font-style: italic;
            letter-spacing: 1px;
        }

        /* 动画定义 */
        @keyframes pulseBlue { to { text-shadow: 0 0 20px rgba(0,210,255,1), 0 0 40px rgba(0,210,255,0.6); } }
        @keyframes pulsePink { to { text-shadow: 0 0 20px rgba(255,75,139,1), 0 0 40px rgba(255,75,139,0.6); } }

        /* 移动端适配 */
        @media (max-width: 768px) {
            .glass-container { padding: 30px 20px; width: 90%; }
            .nickname { font-size: 2.2rem; }
            .t-val { font-size: 1.5rem; }
            .timer-grid { gap: 10px; }
        }
    </style>
</head>
<body>

    <canvas id="cosmos"></canvas>

    <div class="glass-container" id="ui-card">
        <div class="since-date">Stories Began on 2025.08.06</div>
        
        <div class="names-wrapper">
            <div class="name-item nickname male">椰椰宝宝</div>
            <div class="divider">&</div>
            <div class="name-item nickname female">远远宝宝</div>
        </div>

        <div class="timer-grid" id="timer">
            </div>

        <div class="footer-quote">
            "In the sea of stars, I only see you."
        </div>
    </div>

    <script>
        // ================= 配置区 =================
        const START_DATE = '2025-08-06T13:55:00'; // 你们的纪念日
        // =========================================

        /* --------------------------------------
           PART 1: 计时器逻辑
        -------------------------------------- */
        function updateTimer() {
            const start = new Date(START_DATE).getTime();
            const now = new Date().getTime();
            const diff = now - start;

            const days = Math.floor(diff / (86400000));
            const hours = Math.floor((diff % 86400000) / 3600000);
            const minutes = Math.floor((diff % 3600000) / 60000);
            const seconds = Math.floor((diff % 60000) / 1000);

            document.getElementById('timer').innerHTML = `
                <div class="t-box"><span class="t-val">${days}</span><span class="t-label">DAYS</span></div>
                <div class="t-box"><span class="t-val">${hours}</span><span class="t-label">HRS</span></div>
                <div class="t-box"><span class="t-val">${minutes}</span><span class="t-label">MIN</span></div>
                <div class="t-box"><span class="t-val">${seconds}</span><span class="t-label">SEC</span></div>
            `;
        }
        setInterval(updateTimer, 1000);
        updateTimer();

        /* --------------------------------------
           PART 2: 3D UI 视差交互 (Mouse Parallax)
        -------------------------------------- */
        const card = document.getElementById('ui-card');
        document.addEventListener('mousemove', (e) => {
            const xAxis = (window.innerWidth / 2 - e.pageX) / 25; // 旋转力度
            const yAxis = (window.innerHeight / 2 - e.pageY) / 25;
            card.style.transform = `rotateY(${xAxis}deg) rotateX(${yAxis}deg)`;
        });
        // 鼠标移出恢复
        document.addEventListener('mouseleave', () => {
            card.style.transform = `rotateY(0deg) rotateX(0deg)`;
        });

        /* --------------------------------------
           PART 3: 终极星空粒子系统 (Canvas Physics)
        -------------------------------------- */
        const canvas = document.getElementById('cosmos');
        const ctx = canvas.getContext('2d');
        let width, height;
        let particles = [];
        let soulOrbs = []; // 两个主角光球

        // 调整画布
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 辅助函数：随机数
        const rand = (min, max) => Math.random() * (max - min) + min;

        // 类：背景星尘
        class Star {
            constructor() {
                this.x = rand(0, width);
                this.y = rand(0, height);
                this.size = rand(0.5, 2);
                this.speedX = rand(-0.5, 0.5);
                this.speedY = rand(-0.5, 0.5);
                this.alpha = rand(0.1, 0.8);
                this.blinkSpeed = rand(0.005, 0.02);
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.alpha += this.blinkSpeed;
                if (this.alpha > 1 || this.alpha < 0) this.blinkSpeed *= -1;

                // 边界循环
                if (this.x < 0) this.x = width;
                if (this.x > width) this.x = 0;
                if (this.y < 0) this.y = height;
                if (this.y > height) this.y = 0;
            }
            draw() {
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.abs(this.alpha)})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 类：主角光球 (Soul Orb) - 代表你们俩
        class SoulOrb {
            constructor(type) {
                this.type = type; // 'male' or 'female'
                this.angle = rand(0, Math.PI * 2);
                this.radius = rand(150, 250); // 旋转半径
                this.speed = rand(0.01, 0.02);
                this.trail = []; // 拖尾数组
                
                if (type === 'male') {
                    this.color = '0, 210, 255'; // 青蓝
                } else {
                    this.color = '255, 75, 139'; // 粉红
                }
            }

            update() {
                this.angle += this.speed;
                // 计算位置：围绕屏幕中心旋转，但加入正弦波使其不那么规则
                const centerX = width / 2;
                const centerY = height / 2;
                
                // 复杂的轨道计算，制造“缠绕”感
                const x = centerX + Math.cos(this.angle) * this.radius + Math.sin(this.angle * 3) * 50;
                const y = centerY + Math.sin(this.angle) * (this.radius * 0.8) + Math.cos(this.angle * 5) * 30;

                // 记录位置用于画拖尾
                this.trail.push({x, y});
                if (this.trail.length > 20) this.trail.shift();

                return {x, y};
            }

            draw() {
                // 1. 画拖尾 (流光效果)
                ctx.beginPath();
                for (let i = 0; i < this.trail.length; i++) {
                    const point = this.trail[i];
                    // 连线
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                }
                // 拖尾样式
                ctx.strokeStyle = `rgba(${this.color}, 0.4)`;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.stroke();

                // 2. 画核心光球
                const head = this.trail[this.trail.length - 1];
                if (!head) return;

                // 径向渐变，制造发光感
                const gradient = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, 20);
                gradient.addColorStop(0, `rgba(${this.color}, 1)`);
                gradient.addColorStop(0.5, `rgba(${this.color}, 0.5)`);
                gradient.addColorStop(1, `rgba(${this.color}, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(head.x, head.y, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 初始化
        function init() {
            // 生成背景星尘
            for (let i = 0; i < 200; i++) particles.push(new Star());
            // 生成两个主角
            soulOrbs.push(new SoulOrb('male'));
            soulOrbs.push(new SoulOrb('female'));
        }

        // 动画循环
        function animate() {
            // 每次清除画布时覆盖一层半透明黑，制造长拖尾效果 (Motion Blur)
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; 
            ctx.fillRect(0, 0, width, height);

            // 1. 绘制背景星星
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // 开启高亮叠加模式 (光效关键)
            ctx.globalCompositeOperation = 'lighter';

            // 2. 绘制主角光球
            soulOrbs.forEach(orb => {
                orb.update();
                orb.draw();
            });

            // 3. 绘制两个光球之间的连线 (羁绊线)
            if (soulOrbs.length === 2) {
                const p1 = soulOrbs[0].trail[soulOrbs[0].trail.length - 1];
                const p2 = soulOrbs[1].trail[soulOrbs[1].trail.length - 1];
                if (p1 && p2) {
                    // 计算距离
                    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    // 只有当距离比较近时才显示连线
                    const opacity = Math.max(0, 1 - dist / 400); 
                    
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            ctx.globalCompositeOperation = 'source-over'; // 恢复

            requestAnimationFrame(animate);
        }

        init();
        animate();

    </script>
</body>
</html>
